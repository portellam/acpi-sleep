#!/bin/bash

# Filename:       acpi-sleep
# Description:    Allow or deny device(s) to wake-up a Linux machine from a
#                 suspended state. Limit wake-up to matched input devices
#                 (Power, USB, PCI, etc.).
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        1.1.0
#

#region Traps

trap 'catch_error' SIGINT SIGTERM ERR
trap 'catch_exit' EXIT

#endregion

#region Parameters

declare -r SCRIPT_VERSION="1.1.0"
declare -r SCRIPT_NAME="$( basename "${0}" )"
declare -r PREFIX_PROMPT="${SCRIPT_NAME}: "

SAVEIFS="${IFS}"
IFS=$''

  #region Color coding

  # Reference URL : 'https://www.shellhacks.com/bash-colors'
  declare -r SET_COLOR_GREEN='\033[0;32m'
  declare -r SET_COLOR_RED='\033[0;31m'
  declare -r SET_COLOR_YELLOW='\033[0;33m'
  declare -r RESET_COLOR='\033[0m'

  #endregion

  #region Regex

  REGEX_MATCH_IOMMU_GROUP='^[a-zA-Z]+(,[a-zA-Z]+)*$'
  REGEX_MATCH_KEYWORD='^([1-9][0-9]*)(,[1-9][0-9]*)*$'
  REGEX_MATCH_PCI_ID='^([a-zA-Z0-9]{4})(:[a-zA-Z0-9]{4})*$'

  #endregion

  #region Toggles

  DO_PERSIST_CHANGES=false

  DO_PCI_MATCH=false
  PCI_MATCH=""

  DO_PNP_MATCH=false
  PNP_MATCH=""

  BLACKLIST_MATCH=""
  DO_BLACKLIST_ALL_ANY=false
  DO_BLACKLIST_ALL_KBM=false
  DO_BLACKLIST_ALL_NON_KBM=false
  DO_BLACKLIST_ALL_PCI=false
  DO_BLACKLIST_ALL_PNP=false
  DO_BLACKLIST_MATCH=false

  WHITELIST_MATCH=""
  DO_WHITELIST_ALL_ANY=false
  DO_WHITELIST_ALL_KBM=false
  DO_WHITELIST_ALL_NON_KBM=false
  DO_WHITELIST_ALL_PCI=false
  DO_WHITELIST_ALL_PNP=false
  DO_WHITELIST_MATCH=false

  #endregion

PATH_TO_FILE="/proc/acpi/wakeup"

#endregion

#region Logic

#
# $@  : the command line arguments.
# $?  : on success, exit 0; on failure, exit non-zero.
#
function main
{
  is_user_superuser

  if ! set_options "$@"; then
    print_usage
  fi

  exit "${?}"
}

function yes_no_prompt
{
  local output="${1}"
  is_string "${output}" && output+=" "

  for counter in $( seq 0 2 ); do
    echo -en "${output}[Y/n]: "
    read -r -p "" answer

    case "${answer}" in
      [Yy]* )
        return 0 ;;

      [Nn]* )
        return 255 ;;

      * )
        echo "Please answer 'Y' or 'N'." ;;
    esac
  done

  return 1
}

  #region Business logic

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function does_string_contain_iommu_group
  {
    if [[ "${1}" =~ "${REGEX_MATCH_IOMMU_GROUP}" ]]; then
      return 1
    fi
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function does_string_contain_keyword
  {
    if [[ "${1}" =~ "${REGEX_MATCH_KEYWORD}" ]]; then
      return 1
    fi
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function does_string_contain_pci_id
  {
    if [[ "${1}" =~ "${REGEX_MATCH_PCI_ID}" ]]; then
      return 1
    fi
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function does_match_status
  {
    match=""

    case "${1,,}" in
      "disable" | "disabled" )
        match="disable"
        ;;

      "enable" | "enabled" )
        match="enable"
        ;;

      "" )
        ;;

      * )
        return 1
        ;;
    esac

    if "${DO_PCI_MATCH}"; then
      PCI_MATCH="${match}"
    fi

    if "${DO_PNP_MATCH}"; then
      PNP_MATCH="${match}"
    fi
  }

  #
  # $?  : on success, return 0; on failure, exit 1.
  #
  function does_system_have_pci
  {
    if [[ "${#HWID_LIST[@]}" -eq 0 ]]; then
      print_to_error_log "No PCI devices found."
      exit 1
    fi
  }

  #
  # $?  : on success, return 0; on failure, exit 1.
  #
  function find_first_driver
  {
    find_first_vga_driver && return 0
    PREFER_LISTED_BRAND=false
    print_to_error_log "Failed to find preferred GPU."
    find_first_vga_driver && return 0
    print_to_error_log "No GPUs found."
    exit 1
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function find_first_vga_driver
  {
    for hwid in "${HWID_LIST[@]}"; do
      driver=$( \
        lspci -ks "${hwid}" \
          | grep --extended-regexp 'driver' \
          | cut --delimiter ':' --fields 2 \
          | cut --delimiter ' ' --fields 2 \
      )

      type=$( \
        lspci -ms "${hwid}" \
          | cut --delimiter '"' --fields 2 \
          | tr '[:upper:]' '[:lower:]' \
      )

      vendor=$( \
        lspci -ms "${hwid}" \
          | cut --delimiter '"' --fields 4 \
          | tr '[:upper:]' '[:lower:]' \
      )

      function_id=$( \
        echo "${hwid}" \
          | cut --delimiter '.' --fields 2 \
      )

      pci_id=$( \
        echo "${hwid}" \
          | cut --delimiter '.' --fields 1 \
      )

      pci_id+=":${function_id}"

      if match_valid_vga_device_with_driver "driver"; then
        match_driver_and_set_xorg_write_only "${driver}"
        return 0
      fi
    done

    return 1
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function get_preferred_vendor
  {
    local -n reference="${1}"

    case true in
      "${PREFER_AMD}" )
        reference=$( \
          echo -e "${vendor}" \
            | grep --ignore-case --invert-match 'amd|ati' \
            | grep --ignore-case --invert-match 'corporation' \
        ) ;;

      "${PREFER_INTEL}" )
        reference=$( \
          echo -e "${vendor}" \
            | grep --ignore-case 'intel' \
        ) ;;

      "${PREFER_NVIDIA}" )
        reference=$( \
          echo -e "${vendor}" \
            | grep --ignore-case 'nvidia' \
        ) ;;

      "${PREFER_OFF_BRAND}" )
        reference=$( \
          echo -e "${vendor}" \
          | grep \
            --extended-regexp \
            --ignore-case \
            --invert-match \
            'amd|ati|intel|nvidia' \
      ) ;;

      * )
        print_to_error_log "Failed to match preferred vendor."
        return 1 ;;
    esac

    if ! is_string "${reference}" &> /dev/null; then
      return 1
    fi
  }

  #
  # $?  : on success, return 0; on failure, exit 1.
  #
  function is_file_deletable
  {
    if [[ -e "${PATH_1}" ]] \
      && ! sudo rm --force "${FILE_1}" &> /dev/null; then
      print_to_error_log "Failed to delete file '${FILE_1}'."
      exit 1
    fi
  }

  #
  # $1  : the path name.
  # $?  : if path found, return 0.
  #
  function is_path_found
  {
    if [[ ! -d "${PATH_1}" ]] \
      && sudo mkdir --parents "${PATH_1}"; then
      print_to_error_log "Failed to create directory '${PATH_1}'."
      exit 1
    fi
  }

  #
  # $1  : the driver.
  # $?  : always return 0.
  #
  function match_driver_and_set_xorg_write_only
  {
    local -r driver="${1}"

    case "${driver}" in
      *"nouveau"* )
        MATCH_PROBLEM_DRIVER=true ;;
    esac
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function match_valid_vga_device_with_driver
  {
    local -r found_no_driver="Found Driver: 'N/A'"

    if ! is_string "${driver}" &> /dev/null \
      || ! is_string "${type}" &> /dev/null \
      || ! is_string "${vendor}" &> /dev/null; then
      print_to_output_log "${found_no_driver}"
      return 1
    fi

    if ! [[ "${type}" =~ ^"vga" ]] \
      && ! [[ "${type}" =~ ^"graphics" ]]; then
      print_to_output_log "Skipped non-GPU."
      return 1
    fi

    if [[ "${driver}" =~ ^"vfio-pci" ]]; then
      print_to_output_log "${found_no_driver}"
      return 1
    fi

    if "${PREFER_LISTED_BRAND}"; then
      local preferred_vendor=""
      get_preferred_vendor "preferred_vendor"

      if [[ "${preferred_vendor}" != "${vendor}" ]]; then
        print_to_output_log "${found_no_driver}"
        return 1
      fi
    fi

    match_vendor_and_override_driver "${vendor}"
    print_to_output_log "Found Driver: '${driver}'"
  }

  #
  # $1  : the driver.
  # $?  : always return 0.
  #
  function match_vendor_and_override_driver
  {
    local -r vendor="${1}"

    case "${vendor}" in
      *"intel"* )
        override_intel_vga_driver "${driver}" ;;
    esac
  }

  #
  # $1  : the reference.
  # $?  : always return 0.
  #
  function override_intel_vga_driver
  {
    local -n reference="${1}"
    local -r override_driver="modesetting"

    if "${HAS_MATCHED_INTEL_DRIVER}"; then
      reference="${override_driver}"

    else
      print_to_output_log \
        "Should given parsed Intel GPU driver be invalid, replace xorg.conf" \
        "with an alternate intel driver (example: '${override_driver}')."
    fi
  }

  #
  # $?  : on success, return 0; on failure, exit 1.
  #
  function restart_service
  {
    if "${DO_RESTART_DISPLAY_MANAGER}" \
      && ( \
        ! sudo systemctl enable "${FILE_2}" \
        || ! sudo systemctl restart "${FILE_2}" \
      ); then
      print_to_error_log "Failed to restart system service."
      exit 1
    fi

    print_to_output_log "Restarted system service."
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function set_file
  {
    case "${?}" in
      0 )
        FILE_1_CONTENTS+=(
          ""
          "Section       \"Device\""
          "  Identifier  \"Device0\""
          "  Driver      \"${driver}\""
          "  BusID       \"PCI:${pci_id}\""
          "EndSection"
        )

        print_to_output_log "Valid GPU found."
        ;;

      * )
        FILE_1_CONTENTS+=(
          ""
          "#Section       \"Device\""
          "#  Identifier  \"Device0\""
          "#  Driver      \"driver_name\""
          "#  BusID       \"PCI:bus_id:slot_id:function_id\""
          "#EndSection"
        )

        print_to_error_log "No valid GPU found."
        ;;
    esac

    if ! echo -e "${FILE_1_CONTENTS[*]}" >> "${FILE_1}"; then
      print_to_error_log "Failed to write to file '${FILE_1}'."
      return 1
    fi

    print_to_output_log "Wrote to file '${FILE_1}'."
  }

  #
  # $?  : always returns 0.
  #
  function toggle_sort_order_of_devices
  {
    if "${PARSE_PCI_ORDER_BY_BUS_ID}"; then
      HWID_LIST=( $( eval "${GET_PCI_ID}" ) )

    else
      HWID_LIST=( $( eval "${GET_PCI_ID_REVERSE_SORT}" ) )
    fi
  }

  #
  # $?  : on failure, exit 1; on write failure, return 0.
  #
  function write_to_file
  {
    if [[ ! -d "${PATH_1}" ]]; then
      echo -e "${PREFIX_ERROR} Failed to create directory '${PATH_1}'."
      exit 1
    fi

    if ! "${MATCH_PROBLEM_DRIVER}"; then
      set_file || exit "${?}"

    else
      print_to_output_log "Not writing to file given presence of problem driver."
    fi
  }

  #endregion

  #region Options logic

  #
  # $1  : the option.
  # $?  : on success, return 0; on failure, return 1.
  #
  function get_option
  {
    while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do case $1 in
      "--pci" )
        DO_PCI_MATCH=true
        shift

        if ! does_match_status "${1}"; then
          echo -e "${PREFIX_ERROR} Invalid argument."
          return 1
        fi
        ;;

      "--pnp" )
        DO_PNP_MATCH=true
        shift

        if ! does_match_status "${1}"; then
          echo -e "${PREFIX_ERROR} Invalid argument."
          return 1
        fi
        ;;

      "-s" | "--save" )
        DO_PERSIST_CHANGES=true
        ;;

      #region Blacklist

      "--blacklist-all" )
        DO_BLACKLIST_ALL_ANY=true
        ;;

      "--blacklist-kbm" )
        DO_BLACKLIST_ALL_KBM=true
        ;;

      "--blacklist-match" )
        DO_BLACKLIST_MATCH=true
        shift

        if ! does_string_contain_iommu_group "${1}" \
          && ! does_string_contain_keyword "${1}" \
          && ! does_string_contain_pci_id "${1}"; then
          echo -e "${PREFIX_ERROR} Invalid argument."
          return 1
        fi

        BLACKLIST_MATCH="${1}"
        ;;

      "--blacklist-non-kbm" )
        DO_BLACKLIST_ALL_NON_KBM=true
        ;;

      "--blacklist-pci" )
        DO_BLACKLIST_ALL_PCI=true
        ;;

      "--blacklist-pnp" )
        DO_BLACKLIST_ALL_PNP=true
        ;;

      #endregion

      #region Whitelist

      "--whitelist-all" )
        DO_WHITELIST_ALL_ANY=true
        ;;

      "--whitelist-kbm" )
        DO_WHITELIST_ALL_KBM=true
        ;;

      "--whitelist-match" )
        DO_WHITELIST_MATCH=true
        shift

        if ! does_string_contain_iommu_group "${1}" \
          && ! does_string_contain_keyword "${1}" \
          && ! does_string_contain_pci_id "${1}"; then
          echo -e "${PREFIX_ERROR} Invalid argument."
          return 1
        fi

        WHITELIST_MATCH="${1}"
        ;;

      "--whitelist-non-kbm" )
        DO_WHITELIST_ALL_NON_KBM=true
        ;;

      "--whitelist-pci" )
        DO_WHITELIST_ALL_PCI=true
        ;;

      "--whitelist-pnp" )
        DO_WHITELIST_ALL_PNP=true
        ;;

      #endregion

      "" )
        ;;

      "-h" | "--help" )
        return 1 ;;

      * )
        echo -e "${PREFIX_ERROR} Invalid option."
        return 1 ;;
    esac; shift; done

    if [[ "$1" == '--' ]]; then
      shift
    fi
  }

  #
  # $?  : always exits 1.
  #
  function print_usage
  {
    echo -e \
      "$( \
        printf "%s%s%s\n" \
          "Usage: sudo ${SCRIPT_NAME} [OPTION]..." \
          " " \
          "Allow or deny device(s) to wake-up a Linux machine from a suspended" \
            " state. Limit wake-up to matched input devices" \
            " (power, PCI, Plug-and-Play (PnP), FireWire, USB, etc.)." \
          "" \
          "Version ${SCRIPT_VERSION}." \
          "\n\n" \
          "\t-h, --help\t\tPrint this help and exit." \
          "\n" \
          "\t--pci MATCH\t\tGet PCI devices and the ACPI wake status of each." \
          "" \
          "\t\t\t\t" \
          "STATUS is the state of matched devices. STATUS may be either \"enabled\"," \
          " \"disabled\", or empty (match all)." \
          "\n" \
          "\t--pnp MATCH\t\tGet Plug-and-Play (PnP) devices and the ACPI wake status" \
            " of each." \
          "\t\t\t\t" \
          "STATUS is the state of matched devices. STATUS may be either \"enabled\"," \
          " \"disabled\", or empty (match all)." \
          "\n" \
          "\t-s, --save\t\tSave changes so they persist after restart of the Host" \
            " machine." \
          ""

        printf "%s%s%s\n" \
          "\t-b|--blacklist MATCH\tBlacklist individual devices and/or PCI devices" \
            " manually." \
          ""\
          "\t\t\t\t" \
          "MATCH is a comma delimited list of keywords, PCI device IDs, and/or" \
            " IOMMU groups (groups of PCI devices). Keywords include individual or" \
            " PCI device names and types; PCI device IDs are colon delimited pairs of" \
            " four-character alphanumeric words; IOMMU groups are positive numbers." \
          "\n" \
          "\t--blacklist-all\t\tBlacklist all individual devices and PCI devices." \
          "\n\t--blacklist-kbm\t\tBlacklist all individual keyboard-and-mouse (KBM)" \
            " devices." \
          "\t--blacklist-pci\t\tBlacklist all PCI device groups." \
          "\n\t--blacklist-pnp\t\tBlacklist all individual PnP devices and controllers" \
            " (PCI devices)." \
          "\t--blacklist-non-kbm\tBlacklist all individual non-KBM devices." \
          "\n"

        printf "%s%s%s\n" \
          "\t-w|--whitelist MATCH\tWhitelist individual devices and/or PCI devices" \
            " manually." \
          ""\
          "\t\t\t\t" \
          "MATCH is a comma delimited list of keywords, PCI device IDs, and/or" \
            " IOMMU groups (groups of PCI devices). Keywords include individual or" \
            " PCI device names and types; PCI device IDs are colon delimited pairs of" \
            " four-character alphanumeric words; IOMMU groups are positive numbers." \
          "\n" \
          "\t--whitelist-all\t\tWhitelist all individual devices and PCI devices." \
          "\n\t--whitelist-kbm\t\tWhitelist all individual keyboard-and-mouse (KBM)" \
            " devices." \
          "\t--whitelist-pci\t\tWhitelist all PCI device groups." \
          "\n\t--whitelist-pnp\t\tWhitelist all individual PnP devices and controllers" \
            " (PCI devices)." \
          "\t--whitelist-non-kbm\tWhitelist all individual non-KBM devices." \
      )"

    exit 1
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function set_options
  {
    for option in "$@"; do
      is_string "${option}" &> /dev/null || return 0
      get_option "${option}" || return 1
    done
  }

  #endregion

  #region Clean-up

  #
  # $?  : always returns 0.
  #
  function reset_ifs
  {
    IFS="${SAVEIFS}"
  }

  #endregion

  #region Data-type validation

  #
  # $1  : the string.
  # $?  : if not empty string, return 0.
  #
  function is_string
  {
    if [[ "${1}" == "" ]]; then
      return 1
    fi
  }

  #endregion

  #region Handlers

  #
  # $?  : always exits non-zero.
  #
  function catch_error
  {
    exit 255
  }

  #
  # $?  : always returns 0.
  #
  function catch_exit
  {
    reset_ifs
  }

  #
  # $?  : if user is root, return 0.
  #
  function is_user_superuser
  {
    if [[ $( whoami ) != "root" ]]; then
      print_to_error_log "User is not sudo or root."
      return 1
    fi
  }

  #endregion

  #region Loggers

  #
  # $1  : the output.
  # $?  : always returns 0.
  #
  function print_to_error_log
  {
    echo -e "${PREFIX_PROMPT}${PREFIX_ERROR}${*}" >&2
  }

  #
  # $1  : the output.
  # $?  : always returns 0.
  #
  function print_to_output_log
  {
    echo -e "${PREFIX_PROMPT}${*}" >&1
  }

  #endregion

#endregion

#region Main

main "${@}"

#endregion